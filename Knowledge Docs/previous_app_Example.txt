import React, { useState, useEffect, useRef, useMemo, memo } from 'react';
import { Upload, Download, FileText, Plus, Trash2, Eye, Printer, Palette } from 'lucide-react';
import * as Papa from 'papaparse';

// ============================================================================
// ECONOMY SIMULATION
// ============================================================================

const simulateGoldEconomy = (deck1Analysis, deck2Analysis) => {
  if (!deck1Analysis?.minionPool || !deck2Analysis?.minionPool) return null;

  const rounds = 12;
  const trajectories = {
    conservative: { deck1: [], deck2: [] },
    average: { deck1: [], deck2: [] },
    optimistic: { deck1: [], deck2: [] }
  };

  // Playrates for each trajectory
  const playRates = {
    conservative: 0.6,
    average: 0.85,
    optimistic: 1.0
  };

  Object.keys(playRates).forEach(trajectory => {
    const playRate = playRates[trajectory];
    let deck1Gold = 0;
    let deck2Gold = 0;

    for (let round = 1; round <= rounds; round++) {
      const availableMana = Math.min(round, 10); // Hearthstone mana cap

      // Simulate minions played by each deck
      const deck1MinionsPlayed = selectMinionsToPlay(deck1Analysis.minionPool, availableMana, playRate);
      const deck2MinionsPlayed = selectMinionsToPlay(deck2Analysis.minionPool, availableMana, playRate);

      // Each player earns gold from opponent's minions
      deck1Gold += deck2MinionsPlayed.totalBounty;
      deck2Gold += deck1MinionsPlayed.totalBounty;

      trajectories[trajectory].deck1.push({ round, gold: deck1Gold });
      trajectories[trajectory].deck2.push({ round, gold: deck2Gold });
    }
  });

  return trajectories;
};

const selectMinionsToPlay = (minionPool, availableMana, playRate) => {
  // Sort minions by cost (expensive first for greedy packing)
  const sortedMinions = [...minionPool].sort((a, b) => b.cost - a.cost);
  
  let manaToSpend = Math.floor(availableMana * playRate);
  let totalBounty = 0;
  let minionsPlayed = 0;

  // Greedy knapsack: play highest cost minions that fit
  for (const minion of sortedMinions) {
    if (minion.cost <= manaToSpend) {
      manaToSpend -= minion.cost;
      totalBounty += minion.bounty;
      minionsPlayed++;
    }
  }

  return { totalBounty, minionsPlayed };
};

const parseCSV = (file) => {
  return new Promise((resolve, reject) => {
    Papa.parse(file, {
      header: true,
      dynamicTyping: true,
      skipEmptyLines: true,
      complete: (results) => {
        const parsedCards = results.data.map((row, idx) => ({
          ...row,
          id: `${Date.now()}-${idx}`
        }));
        resolve(parsedCards);
      },
      error: (error) => reject(error)
    });
  });
};

const getDefaultCustomization = (type) => {
  if (type === 'equipment') {
    return {
      weapon: { color: '#D97706' },
      chest: { color: '#6B7280' },
      jewelry: { color: '#7C3AED' },
      relic: { color: '#2563EB' },
      consumable: { color: '#059669' },
      font: 'Arial, sans-serif'
    };
  }
  return {
    minion: { color: '#059669' },
    spell: { color: '#2563EB' },
    upgrade: { color: '#7C3AED' },
    ultimate: { color: '#DC2626' },
    font: 'Arial, sans-serif'
  };
};

const applyKeywordBolding = (text, keywords) => {
  if (!text || keywords.length === 0) return text;
  let result = text;
  keywords.forEach(keyword => {
    const regex = new RegExp(`\\b${keyword}\\b`, 'g');
    result = result.replace(regex, `<strong>${keyword}</strong>`);
  });
  return result;
};

const analyzeDeck = (deck, keywords) => {
  if (!deck?.cards) return null;

  // CRITICAL: Deduplicate by card name
  const uniqueCardsMap = new Map();
  deck.cards.forEach(card => {
    const cardName = card['Card Name'] || card['Item Name'];
    if (cardName && !uniqueCardsMap.has(cardName)) {
      uniqueCardsMap.set(cardName, card);
    }
  });
  
  const uniqueCards = Array.from(uniqueCardsMap.values());
  
  const manaCurve = {};
  const minionManaCurve = {};
  const spellManaCurve = {};
  
  uniqueCards.forEach(card => {
    const cost = card['Mana Cost'] || 0;
    const copies = card.Copies || 1;
    const cardType = card['Card Type'];
    
    manaCurve[cost] = (manaCurve[cost] || 0) + copies;
    if (cardType === 'Minion') minionManaCurve[cost] = (minionManaCurve[cost] || 0) + copies;
    if (cardType === 'Spell') spellManaCurve[cost] = (spellManaCurve[cost] || 0) + copies;
  });

  const spellCount = uniqueCards.reduce((sum, card) => 
    sum + (card['Card Type'] === 'Spell' ? (card.Copies || 1) : 0), 0);
  const minionCount = uniqueCards.reduce((sum, card) => 
    sum + (card['Card Type'] === 'Minion' ? (card.Copies || 1) : 0), 0);

  let totalAttack = 0, totalHealth = 0, totalMinionGold = 0;
  
  // Build minion pool for economy simulation
  const minionPool = [];
  uniqueCards.forEach(card => {
    if (card['Card Type'] === 'Minion') {
      const copies = card.Copies || 1;
      const cost = card['Mana Cost'] || 0;
      const bountyStr = card.Bounty || '0g';
      const bountyValue = parseInt(bountyStr.replace(/[^0-9]/g, '')) || 0;
      
      totalAttack += (card.Attack || 0) * copies;
      totalHealth += (card.Health || 0) * copies;
      totalMinionGold += bountyValue * copies;
      
      // Add each copy to pool for simulation
      for (let i = 0; i < copies; i++) {
        minionPool.push({ cost, bounty: bountyValue });
      }
    }
  });

  let keywordCards = 0, nonKeywordCards = 0;
  uniqueCards.forEach(card => {
    const effect = card.Effect || '';
    const copies = card.Copies || 1;
    const hasKeyword = keywords.some(keyword => 
      new RegExp(`\\b${keyword}\\b`, 'i').test(effect)
    );
    hasKeyword ? keywordCards += copies : nonKeywordCards += copies;
  });

  return {
    manaCurve,
    minionManaCurve,
    spellManaCurve,
    spellCount,
    minionCount,
    totalAttack,
    totalHealth,
    totalMinionGold,
    uniqueCards: uniqueCards.length,
    keywordCards,
    nonKeywordCards,
    totalCards: uniqueCards.reduce((sum, card) => sum + (card.Copies || 1), 0),
    minionPool // For economy simulation
  };
};

// ============================================================================
// UI COMPONENTS
// ============================================================================

const AutoSizeEffectText = memo(({ text, standardSize, minSize }) => {
  const containerRef = useRef(null);
  const textRef = useRef(null);
  const [fontSize, setFontSize] = useState(standardSize);
  const [lineHeight, setLineHeight] = useState(1.3);
  const safeText = text || '';
  
  useEffect(() => {
    if (!containerRef.current || !textRef.current || !safeText) return;
    
    const container = containerRef.current;
    const textElement = textRef.current;
    
    let currentSize = standardSize;
    let currentLineHeight = 1.3;
    
    const fitText = () => {
      // Set initial values
      setFontSize(currentSize);
      setLineHeight(currentLineHeight);
      
      // Multiple RAF to ensure paint is done
      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            // Force reflow
            void textElement.offsetHeight;
            
            const containerHeight = container.clientHeight;
            const textHeight = textElement.scrollHeight;
            
            // If text overflows
            if (textHeight > containerHeight && currentSize > minSize) {
              // Try reducing font size first
              if (currentSize > minSize + 1) {
                currentSize -= 1;
                fitText();
              } 
              // If we're near minimum, try tightening line height
              else if (currentLineHeight > 1.1) {
                currentLineHeight -= 0.05;
                fitText();
              }
              // Last resort: go to absolute minimum
              else if (currentSize > minSize) {
                currentSize = minSize;
                currentLineHeight = 1.1;
                fitText();
              }
            }
          });
        });
      });
    };
    
    fitText();
  }, [safeText, standardSize, minSize]);
  
  return (
    <div ref={containerRef} style={{
      flex: 1,
      margin: '1.5mm 2mm 1mm 2mm',
      padding: '1mm 1.5mm',
      overflow: 'hidden',
      position: 'relative',
      display: 'flex',
      alignItems: 'flex-start'
    }}>
      <p ref={textRef} style={{ 
        margin: 0,
        fontSize: `${fontSize}pt`,
        color: '#000',
        lineHeight: lineHeight,
        wordWrap: 'break-word',
        overflowWrap: 'break-word',
        hyphens: 'auto',
        width: '100%'
      }} dangerouslySetInnerHTML={{ __html: safeText }} />
    </div>
  );
});

const EquipmentCard = memo(({ card, customization, textSettings, keywords }) => {
  const slot = card.Slot?.toLowerCase();
  const category = card.Category?.toLowerCase();
  const color = customization[slot]?.color || customization[category]?.color || customization.weapon?.color || '#000';
  const effectHTML = applyKeywordBolding(card.Effect || '', keywords);

  return (
    <div style={{
      width: '63mm',
      height: '88mm',
      backgroundColor: '#fff',
      border: '2px solid #000',
      borderRadius: '3mm',
      boxSizing: 'border-box',
      fontFamily: customization.font,
      display: 'flex',
      flexDirection: 'column',
      overflow: 'hidden',
      position: 'relative'
    }}>
      {/* Header - no cost here anymore */}
      <div style={{
        borderBottom: `3px solid ${color}`,
        padding: '1.5mm 2mm',
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center'
      }}>
        <h1 style={{
          fontSize: `${textSettings.cardNameSize}pt`,
          fontWeight: 'bold',
          color: '#000',
          margin: 0,
          lineHeight: 1,
          flex: 1
        }}>{card['Item Name']}</h1>
      </div>

      {/* Tier stars */}
      {card.Tier && (
        <div style={{
          padding: '0.5mm 0',
          textAlign: 'center',
          borderBottom: '1px solid #E5E7EB',
          fontSize: '8pt'
        }}>
          {[...Array(card.Tier)].map((_, i) => (
            <span key={i} style={{ color, marginRight: '0.5px' }}>‚òÖ</span>
          ))}
        </div>
      )}

      {/* Image - much smaller */}
      <div style={{
        flex: '0 0 25%',
        margin: '1.5mm 2mm',
        border: '1px solid #D1D5DB',
        borderRadius: '2mm',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: '#FFFFFF'
      }}>
        <div style={{ fontSize: '24pt', color: '#D1D5DB' }}>
          {card.Slot === 'Weapon' && '‚öî'}
          {card.Slot === 'Chest' && 'üõ°'}
          {card.Slot === 'Jewelry' && 'üíç'}
          {card.Slot === 'Relic' && '‚óÜ'}
          {card.Category === 'Consumable' && 'üß™'}
        </div>
      </div>

      {/* Type line - compressed */}
      <div style={{
        padding: '1mm 2mm',
        borderTop: '1px solid #E5E7EB',
        borderBottom: '1px solid #E5E7EB',
        backgroundColor: '#F9FAFB'
      }}>
        <h2 style={{ fontSize: '7pt', fontWeight: 'bold', color: '#000', margin: 0, lineHeight: 1.2 }}>
          Equipment ‚Äî {card.Slot || card.Category}
          {card['Relic Type'] && <span style={{ fontStyle: 'italic', marginLeft: '3px', fontWeight: 'normal' }}>({card['Relic Type']})</span>}
        </h2>
      </div>

      {/* Effect text - THE STAR */}
      <AutoSizeEffectText 
        text={effectHTML}
        standardSize={textSettings.standardEffectSize}
        minSize={textSettings.minEffectSize}
      />

      {/* Cost in bottom left corner box (matches bounty style) */}
      <div style={{
        position: 'absolute',
        bottom: '2mm',
        left: '2mm',
        backgroundColor: '#fff',
        border: '1.5px solid #000',
        padding: '1mm 2mm',
        borderRadius: '1.5mm',
        fontSize: '9pt',
        fontWeight: 'bold',
        lineHeight: 1,
        display: 'flex',
        alignItems: 'center',
        gap: '1mm'
      }}>
        <span>üí∞ {card.Cost}g</span>
      </div>

      {/* Tier/Phase info in bottom right if exists */}
      {(card.Tier || card['Shop Phase']) && (
        <div style={{
          position: 'absolute',
          bottom: '2mm',
          right: '2mm',
          backgroundColor: '#fff',
          border: '1.5px solid #000',
          borderRadius: '1.5mm',
          padding: '1mm 2mm',
          fontSize: '7pt',
          fontWeight: 'bold',
          lineHeight: 1.2
        }}>
          {card.Tier && <span>T{card.Tier}</span>}
          {card.Tier && card['Shop Phase'] && <span> ‚Ä¢ </span>}
          {card['Shop Phase'] && <span>{card['Shop Phase']}</span>}
        </div>
      )}
    </div>
  );
});

const ClassCard = memo(({ card, customization, textSettings, keywords }) => {
  const type = card['Card Type']?.toLowerCase();
  const color = customization[type]?.color || customization.minion?.color || '#000';
  const isMinion = card['Card Type'] === 'Minion';
  const effectHTML = applyKeywordBolding(card.Effect || '', keywords);

  return (
    <div style={{
      width: '63mm',
      height: '88mm',
      backgroundColor: '#fff',
      border: '2px solid #000',
      borderRadius: '3mm',
      boxSizing: 'border-box',
      fontFamily: customization.font,
      display: 'flex',
      flexDirection: 'column',
      overflow: 'hidden',
      position: 'relative'
    }}>
      {/* Header */}
      <div style={{
        borderBottom: `3px solid ${color}`,
        padding: '1.5mm 2mm',
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center'
      }}>
        <h1 style={{
          fontSize: `${textSettings.cardNameSize}pt`,
          fontWeight: 'bold',
          color: '#000',
          margin: 0,
          lineHeight: 1,
          flex: 1
        }}>{card['Card Name']}</h1>
        
        <div style={{ display: 'flex', alignItems: 'center', gap: '1mm', marginLeft: '2mm' }}>
          <span style={{ fontSize: '13pt', lineHeight: 1 }}>‚óÜ</span>
          <span style={{ fontSize: `${textSettings.costSize}pt`, fontWeight: 'bold' }}>{card['Mana Cost'] || 0}</span>
        </div>
      </div>

      {/* Image - much smaller */}
      <div style={{
        flex: '0 0 25%',
        margin: '1.5mm 2mm',
        border: '1px solid #D1D5DB',
        borderRadius: '2mm',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        backgroundColor: '#FFFFFF'
      }}>
        <div style={{ fontSize: '24pt', color: '#D1D5DB' }}>
          {card['Card Type'] === 'Minion' && '‚öî'}
          {card['Card Type'] === 'Spell' && '‚óÜ'}
          {card['Card Type'] === 'Upgrade' && '‚¨Ü'}
          {card['Card Type'] === 'Ultimate' && '‚ñ≤'}
        </div>
      </div>

      {/* Type line - compressed */}
      <div style={{
        padding: '1mm 2mm',
        borderTop: '1px solid #E5E7EB',
        borderBottom: '1px solid #E5E7EB',
        backgroundColor: '#F9FAFB'
      }}>
        <h2 style={{ fontSize: '7pt', fontWeight: 'bold', color: '#000', margin: 0, lineHeight: 1.2 }}>
          {card['Card Type']}
          {card['Upgrade Slot'] && <span style={{ fontStyle: 'italic', marginLeft: '3px', fontWeight: 'normal' }}>‚Äî {card['Upgrade Slot']}</span>}
        </h2>
      </div>

      {/* Effect text - THE STAR */}
      <AutoSizeEffectText 
        text={effectHTML}
        standardSize={textSettings.standardEffectSize}
        minSize={textSettings.minEffectSize}
      />

      {/* Stats corner box (MTG style) - bottom right */}
      {isMinion && (
        <div style={{
          position: 'absolute',
          bottom: '2mm',
          right: '2mm',
          backgroundColor: '#fff',
          border: '2px solid #000',
          borderRadius: '2mm',
          padding: '1.5mm 3mm',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center'
        }}>
          <span style={{
            fontSize: '11pt',
            fontWeight: 'bold',
            color: '#000',
            lineHeight: 1
          }}>
            {card.Attack}/{card.Health}
          </span>
        </div>
      )}

      {/* Bounty/Copies in bottom left corner */}
      {(isMinion && card.Bounty) || card.Copies ? (
        <div style={{
          position: 'absolute',
          bottom: '2mm',
          left: '2mm',
          display: 'flex',
          gap: '2mm',
          alignItems: 'center'
        }}>
          {isMinion && card.Bounty && (
            <div style={{
              backgroundColor: '#fff',
              border: '1.5px solid #000',
              padding: '1mm 2mm',
              borderRadius: '1.5mm',
              fontSize: '9pt',
              fontWeight: 'bold',
              lineHeight: 1
            }}>
              üí∞ {card.Bounty}
            </div>
          )}
          {card.Copies && (
            <div style={{
              backgroundColor: '#fff',
              border: '1.5px solid #000',
              padding: '1mm 2mm',
              borderRadius: '1.5mm',
              fontSize: '9pt',
              fontWeight: 'bold',
              lineHeight: 1
            }}>
              √ó{card.Copies}
            </div>
          )}
        </div>
      ) : null}
    </div>
  );
});

const MTGCard = memo(({ card, customization, textSettings, keywords }) => {
  const isEquipment = card['Item Name'] !== undefined;
  return isEquipment ? (
    <EquipmentCard card={card} customization={customization} textSettings={textSettings} keywords={keywords} />
  ) : (
    <ClassCard card={card} customization={customization} textSettings={textSettings} keywords={keywords} />
  );
});

const DecklistDisplay = memo(({ cards, color }) => {
  const uniqueCardsMap = new Map();
  cards.forEach(card => {
    const cardName = card['Card Name'] || card['Item Name'];
    if (cardName && !uniqueCardsMap.has(cardName)) {
      uniqueCardsMap.set(cardName, card);
    }
  });
  const uniqueCardsList = Array.from(uniqueCardsMap.values());

  return (
    <div className={`mb-6 bg-zinc-950 border-2 border-${color}-600 p-4 max-h-96 overflow-y-auto`}>
      <h3 className={`text-sm font-bold text-${color}-400 mb-3 tracking-wide sticky top-0 bg-zinc-950 pb-2`}>DECKLIST</h3>
      <div className="space-y-1">
        {uniqueCardsList.map((card, idx) => (
          <div key={idx} className={`p-2 text-xs ${idx % 2 === 0 ? 'bg-zinc-900' : 'bg-zinc-900/50'}`}>
            <div className="flex items-start gap-3">
              <div className="flex-shrink-0 w-6 text-center">
                <span className="text-white font-bold text-xs">{card.Copies || 1}√ó</span>
              </div>
              <div className="flex-shrink-0 w-8 text-center">
                <span className={`text-${color}-400 font-mono font-bold`}>{card['Mana Cost'] || 0}</span>
              </div>
              <div className="flex-1 min-w-0">
                <div className="flex items-center gap-2 mb-1">
                  <span className="font-bold text-white truncate">{card['Card Name']}</span>
                  <span className={`text-xs px-1.5 py-0.5 rounded ${
                    card['Card Type'] === 'Minion' ? 'bg-green-600/30 text-green-400' :
                    card['Card Type'] === 'Spell' ? 'bg-blue-600/30 text-blue-400' :
                    card['Card Type'] === 'Upgrade' ? 'bg-purple-600/30 text-purple-400' :
                    'bg-red-600/30 text-red-400'
                  }`}>
                    {card['Card Type']}
                  </span>
                  {card['Card Type'] === 'Minion' && (
                    <>
                      <span className="text-zinc-500">|</span>
                      <span className="text-white font-mono text-xs">{card.Attack}/{card.Health}</span>
                      <span className="text-zinc-500">|</span>
                      <span className="text-amber-500 text-xs">{card.Bounty}</span>
                    </>
                  )}
                </div>
                <p className="text-zinc-400 text-xs leading-tight line-clamp-2">{card.Effect || 'No effect text'}</p>
              </div>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
});

const ManaCurveDisplay = memo(({ curve, totalCards, color, title }) => {
  if (Object.keys(curve).length === 0) {
    return (
      <>
        <h4 className={`text-base font-bold text-${color}-400 mb-3 tracking-wide`}>{title}</h4>
        <p className="text-zinc-600 text-sm italic">No cards in this category</p>
      </>
    );
  }

  return (
    <>
      <h4 className={`text-base font-bold text-${color}-400 mb-3 tracking-wide`}>{title}</h4>
      <div className="space-y-2">
        {Object.entries(curve).sort(([a], [b]) => parseInt(a) - parseInt(b)).map(([cost, count]) => (
          <div key={cost} className="flex items-center gap-2">
            <span className="text-white font-mono w-6 text-sm">{cost}:</span>
            <div className="flex-1 bg-zinc-900 h-5 relative">
              <div 
                className={`bg-${color}-600 h-full transition-all`}
                style={{ width: `${(count / totalCards) * 100}%` }}
              />
            </div>
            <span className="text-zinc-400 font-mono w-10 text-right text-sm">{count}x</span>
          </div>
        ))}
      </div>
    </>
  );
});

const DeckAnalysisPanel = memo(({ deck, analysis, color }) => {
  if (!analysis) {
    return (
      <div className="bg-zinc-950 border-2 border-dashed border-zinc-800 p-12 text-center">
        <FileText className="w-12 h-12 text-zinc-700 mx-auto mb-3" />
        <p className="text-zinc-500">Select a deck above</p>
      </div>
    );
  }

  return (
    <div className={`bg-zinc-950 border-2 border-${color}-600 p-4 space-y-6`}>
      <h3 className="text-xl font-bold text-white tracking-wide">{deck.name}</h3>
      
      <div>
        <ManaCurveDisplay 
          curve={analysis.manaCurve} 
          totalCards={analysis.totalCards} 
          color={color}
          title="MANA CURVE (ALL CARDS)"
        />
      </div>

      <div>
        <ManaCurveDisplay 
          curve={analysis.minionManaCurve} 
          totalCards={analysis.minionCount} 
          color={color}
          title="MINION MANA CURVE"
        />
      </div>

      <div>
        <ManaCurveDisplay 
          curve={analysis.spellManaCurve} 
          totalCards={analysis.spellCount} 
          color={color}
          title="SPELL MANA CURVE"
        />
      </div>

      <div>
        <h4 className={`text-base font-bold text-${color}-400 mb-3 tracking-wide`}>CARD TYPES</h4>
        <div className="space-y-2">
          <div className="flex justify-between items-center bg-zinc-900 p-2">
            <span className="text-white text-sm">Spells</span>
            <span className={`text-${color}-400 font-bold`}>{analysis.spellCount}</span>
          </div>
          <div className="flex justify-between items-center bg-zinc-900 p-2">
            <span className="text-white text-sm">Minions</span>
            <span className={`text-${color}-400 font-bold`}>{analysis.minionCount}</span>
          </div>
        </div>
      </div>

      <div>
        <h4 className={`text-base font-bold text-${color}-400 mb-3 tracking-wide`}>MINION STRENGTH</h4>
        <div className="bg-zinc-900 p-3 text-center">
          <span className="text-2xl font-bold text-white">
            {analysis.totalAttack} / {analysis.totalHealth}
          </span>
          <p className="text-zinc-500 text-xs mt-1">Attack / Health</p>
        </div>
      </div>

      <div>
        <h4 className={`text-base font-bold text-${color}-400 mb-3 tracking-wide`}>TOTAL MINION GOLD</h4>
        <div className="bg-zinc-900 p-3 text-center">
          <span className="text-2xl font-bold text-amber-500">üí∞ {analysis.totalMinionGold}g</span>
          <p className="text-zinc-500 text-xs mt-1">If all minions killed</p>
        </div>
      </div>

      <div>
        <h4 className={`text-base font-bold text-${color}-400 mb-3 tracking-wide`}>UNIQUE CARDS</h4>
        <div className="flex justify-between items-center bg-zinc-900 p-2">
          <span className="text-white text-sm">Distinct cards</span>
          <span className={`text-${color}-400 font-bold`}>{analysis.uniqueCards}</span>
        </div>
      </div>

      <div>
        <h4 className={`text-base font-bold text-${color}-400 mb-3 tracking-wide`}>KEYWORD USAGE</h4>
        <div className="space-y-2">
          <div className="flex justify-between items-center bg-zinc-900 p-2">
            <span className="text-white text-sm">With keywords</span>
            <span className={`text-${color}-400 font-bold`}>{analysis.keywordCards}</span>
          </div>
          <div className="flex justify-between items-center bg-zinc-900 p-2">
            <span className="text-white text-sm">Without keywords</span>
            <span className="text-zinc-400 font-bold">{analysis.nonKeywordCards}</span>
          </div>
        </div>
      </div>
    </div>
  );
});

const A4PrintLayout = memo(({ deck, textSettings, keywords, easyPrintMode = false }) => {
  const cardsPerPage = 9;
  const pages = [];
  
  for (let i = 0; i < deck.cards.length; i += cardsPerPage) {
    pages.push(deck.cards.slice(i, i + cardsPerPage));
  }

  if (easyPrintMode) {
    // Easy Print Mode - tight layout for easy cutting, centered on page
    return (
      <div>
        {pages.map((pageCards, pageIdx) => (
          <div key={pageIdx} style={{
            width: '210mm',
            height: '297mm',
            position: 'relative',
            pageBreakAfter: 'always',
            margin: '0 auto',
            background: '#fff',
            boxSizing: 'border-box',
            display: 'flex',
            alignItems: 'center',
            justifyContent: 'center'
          }}>
            <div style={{
              display: 'grid',
              gridTemplateColumns: 'repeat(3, 63mm)',
              gridTemplateRows: 'repeat(3, 88mm)',
              gap: '1px'
            }}>
              {pageCards.map((card) => (
                <div key={card.id}>
                  <MTGCard card={card} customization={deck.customization} textSettings={textSettings} keywords={keywords} />
                </div>
              ))}
            </div>

            <div style={{
              position: 'absolute',
              bottom: '5mm',
              right: '10mm',
              fontSize: '10pt',
              color: '#666'
            }}>
              Page {pageIdx + 1} of {pages.length}
            </div>
          </div>
        ))}
      </div>
    );
  }

  // Normal mode with cut guides
  return (
    <div>
      {pages.map((pageCards, pageIdx) => (
        <div key={pageIdx} style={{
          width: '210mm',
          height: '297mm',
          position: 'relative',
          pageBreakAfter: 'always',
          margin: '0 auto',
          background: '#fff',
          padding: '10.5mm 10.5mm 16.5mm 10.5mm',
          boxSizing: 'border-box'
        }}>
          <div style={{
            display: 'grid',
            gridTemplateColumns: 'repeat(3, 63mm)',
            gridTemplateRows: 'repeat(3, 88mm)',
            gap: '2mm',
            position: 'relative'
          }}>
            <div style={{
              position: 'absolute',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              pointerEvents: 'none'
            }}>
              <div style={{ position: 'absolute', left: '65mm', top: '-5mm', bottom: '-5mm', width: '1px', borderLeft: '1px dashed #CCC' }} />
              <div style={{ position: 'absolute', left: '130mm', top: '-5mm', bottom: '-5mm', width: '1px', borderLeft: '1px dashed #CCC' }} />
              <div style={{ position: 'absolute', top: '90mm', left: '-5mm', right: '-5mm', height: '1px', borderTop: '1px dashed #CCC' }} />
              <div style={{ position: 'absolute', top: '180mm', left: '-5mm', right: '-5mm', height: '1px', borderTop: '1px dashed #CCC' }} />
            </div>

            {pageCards.map((card) => (
              <div key={card.id}>
                <MTGCard card={card} customization={deck.customization} textSettings={textSettings} keywords={keywords} />
              </div>
            ))}
          </div>

          <div style={{
            position: 'absolute',
            bottom: '5mm',
            right: '10mm',
            fontSize: '10pt',
            color: '#666'
          }}>
            Page {pageIdx + 1} of {pages.length}
          </div>
        </div>
      ))}
    </div>
  );
});

// ============================================================================
// MAIN COMPONENT
// ============================================================================

const CardGenerator = () => {
  const [currentTab, setCurrentTab] = useState('home');
  const [decks, setDecks] = useState([]);
  const [selectedDeck, setSelectedDeck] = useState(null);
  const [showCreateModal, setShowCreateModal] = useState(false);
  const [showCustomize, setShowCustomize] = useState(false);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [deckToDelete, setDeckToDelete] = useState(null);
  
  const [newDeckName, setNewDeckName] = useState('');
  const [newDeckType, setNewDeckType] = useState('hero');
  const [uploadedCards, setUploadedCards] = useState([]);
  
  const [balanceDeck1, setBalanceDeck1] = useState(null);
  const [balanceDeck2, setBalanceDeck2] = useState(null);

  const [keywords, setKeywords] = useState([]);
  const [newKeyword, setNewKeyword] = useState('');
  const [textSettings, setTextSettings] = useState({
    standardEffectSize: 11,
    minEffectSize: 6,
    cardNameSize: 11,
    typeLineSize: 6,
    costSize: 12
  });

  const [exportFilter, setExportFilter] = useState('all');
  const [easyPrintMode, setEasyPrintMode] = useState(false);
  const [balancingSubTab, setBalancingSubTab] = useState('general');
  const [economyEquipmentDeck, setEconomyEquipmentDeck] = useState(null);

  // Load from localStorage
  useEffect(() => {
    const savedDecks = localStorage.getItem('cardDecks');
    const savedKeywords = localStorage.getItem('cardKeywords');
    const savedTextSettings = localStorage.getItem('textSettings');
    
    if (savedDecks) setDecks(JSON.parse(savedDecks));
    if (savedKeywords) setKeywords(JSON.parse(savedKeywords));
    if (savedTextSettings) setTextSettings(JSON.parse(savedTextSettings));
  }, []);

  // Save to localStorage
  useEffect(() => {
    if (decks.length > 0) {
      localStorage.setItem('cardDecks', JSON.stringify(decks));
    } else {
      localStorage.removeItem('cardDecks');
    }
  }, [decks]);

  useEffect(() => {
    localStorage.setItem('cardKeywords', JSON.stringify(keywords));
  }, [keywords]);

  useEffect(() => {
    localStorage.setItem('textSettings', JSON.stringify(textSettings));
  }, [textSettings]);

  // Memoized analyses
  const deck1Analysis = useMemo(() => 
    balanceDeck1 ? analyzeDeck(balanceDeck1, keywords) : null, 
    [balanceDeck1, keywords]
  );
  
  const deck2Analysis = useMemo(() => 
    balanceDeck2 ? analyzeDeck(balanceDeck2, keywords) : null, 
    [balanceDeck2, keywords]
  );

  // Filter cards for export based on State column
  const filteredExportCards = useMemo(() => {
    if (!selectedDeck || currentTab !== 'export') return [];
    
    if (exportFilter === 'all') return selectedDeck.cards;
    
    return selectedDeck.cards.filter(card => {
      const state = card.State || '';
      if (exportFilter === 'print-new') return state === 'Print New';
      if (exportFilter === 'updated') return state === 'Updated';
      return true;
    });
  }, [selectedDeck, exportFilter, currentTab]);

  const handleFileUpload = async (e) => {
    const file = e.target.files[0];
    if (file) {
      try {
        const cards = await parseCSV(file);
        setUploadedCards(cards);
      } catch (error) {
        alert('Error parsing CSV: ' + error.message);
      }
    }
  };

  const saveDeck = () => {
    if (!newDeckName.trim()) return alert('Please enter a deck name');
    if (uploadedCards.length === 0) return alert('Please upload a CSV file');

    const newDeck = {
      id: Date.now(),
      name: newDeckName,
      type: newDeckType,
      cards: uploadedCards,
      customization: getDefaultCustomization(newDeckType),
      createdAt: new Date().toISOString()
    };

    setDecks([...decks, newDeck]);
    setShowCreateModal(false);
    setNewDeckName('');
    setUploadedCards([]);
    setCurrentTab('view');
  };

  const deleteDeck = (deckId) => {
    setDeckToDelete(deckId);
    setShowDeleteConfirm(true);
  };

  const confirmDelete = () => {
    if (deckToDelete) {
      setDecks(decks.filter(d => d.id !== deckToDelete));
      setShowDeleteConfirm(false);
      setDeckToDelete(null);
    }
  };

  const downloadAsHTML = () => {
    if (!selectedDeck) return;
    
    const pageContent = document.querySelector('[data-export-content]');
    if (!pageContent) return alert('Content not ready. Please try again.');

    const htmlContent = `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>${selectedDeck.name} - Print Ready</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { background: white; }
    @page { size: A4; margin: 0; }
    @media print { .no-print { display: none !important; } }
  </style>
</head>
<body>
  ${pageContent.innerHTML}
  <div class="no-print" style="position: fixed; top: 20px; right: 20px; background: #000; color: #fff; padding: 20px; border: 2px solid #f59e0b; border-radius: 8px; font-family: Arial;">
    <p style="font-weight: bold; margin-bottom: 10px;">üìÑ Ready to Print!</p>
    <p style="font-size: 14px; margin-bottom: 10px;">Press <strong>Ctrl+P</strong> (or Cmd+P on Mac)</p>
    <p style="font-size: 14px;">Select "Save as PDF" as destination</p>
  </div>
</body>
</html>`;

    const blob = new Blob([htmlContent], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${selectedDeck.name.replace(/[^a-z0-9]/gi, '_')}_printable.html`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const viewDeck = (deck) => {
    setSelectedDeck(deck);
    setCurrentTab('deck-view');
  };

  const exportDeck = (deck) => {
    setSelectedDeck(deck);
    setExportFilter('all'); // Reset filter when entering export mode
    setEasyPrintMode(false); // Reset easy print mode
    setCurrentTab('export');
  };

  const updateDeckCustomization = (updates) => {
    const updatedDeck = {
      ...selectedDeck,
      customization: { ...selectedDeck.customization, ...updates }
    };
    setSelectedDeck(updatedDeck);
    setDecks(decks.map(d => d.id === updatedDeck.id ? updatedDeck : d));
  };

  const addKeyword = () => {
    if (newKeyword.trim() && !keywords.includes(newKeyword.trim())) {
      setKeywords([...keywords, newKeyword.trim()]);
      setNewKeyword('');
    }
  };

  const removeKeyword = (keyword) => {
    setKeywords(keywords.filter(k => k !== keyword));
  };

  const updateTextSetting = (key, value) => {
    setTextSettings({ ...textSettings, [key]: parseInt(value) || 6 });
  };

  return (
    <div className="min-h-screen bg-black">
      <div className="bg-zinc-950 border-b border-zinc-800">
        <div className="max-w-7xl mx-auto px-8">
          <nav className="flex gap-1">
            {[
              ['home', 'HOME'],
              ['view', 'MY DECKS'],
              ['balancing', 'BALANCING'],
              ['text-tweaks', 'TEXT TWEAKS']
            ].map(([tab, label]) => (
              <button
                key={tab}
                onClick={() => setCurrentTab(tab)}
                className={`px-6 py-4 font-bold transition border-b-2 ${
                  currentTab === tab || (tab === 'view' && ['deck-view', 'export'].includes(currentTab))
                    ? 'text-amber-500 border-amber-500 bg-zinc-900/50'
                    : 'text-zinc-500 border-transparent hover:text-zinc-300 hover:border-zinc-700'
                }`}
              >
                {label}
              </button>
            ))}
          </nav>
        </div>
      </div>

      <div className="max-w-7xl mx-auto p-8">
        {currentTab === 'home' && (
          <div>
            <div className="text-center mb-12">
              <h1 className="text-6xl font-bold text-amber-500 mb-4 tracking-wider">CARD GENERATOR</h1>
              <p className="text-xl text-zinc-400 tracking-wide">CREATE ‚Ä¢ CUSTOMIZE ‚Ä¢ CONQUER</p>
            </div>

            <div className="grid md:grid-cols-2 gap-6">
              <button
                onClick={() => setShowCreateModal(true)}
                className="bg-zinc-900 border-2 border-zinc-800 hover:border-amber-600 text-white p-8 flex flex-col items-center gap-4 transition group"
              >
                <Plus className="w-16 h-16 text-amber-500 group-hover:text-amber-400" />
                <h2 className="text-2xl font-bold tracking-wide">CREATE NEW DECK</h2>
                <p className="text-zinc-400">Upload CSV and start building</p>
              </button>

              <button
                onClick={() => setCurrentTab('view')}
                className="bg-zinc-900 border-2 border-zinc-800 hover:border-red-600 text-white p-8 flex flex-col items-center gap-4 transition group"
              >
                <Eye className="w-16 h-16 text-red-500 group-hover:text-red-400" />
                <h2 className="text-2xl font-bold tracking-wide">VIEW MY DECKS</h2>
                <p className="text-zinc-400">{decks.length} deck{decks.length !== 1 ? 's' : ''} saved</p>
              </button>
            </div>
          </div>
        )}

        {currentTab === 'view' && (
          <div>
            <div className="flex justify-between items-center mb-8">
              <h1 className="text-4xl font-bold text-amber-500 tracking-wider">MY DECKS</h1>
              <button
                onClick={() => setShowCreateModal(true)}
                className="bg-zinc-900 border-2 border-amber-600 hover:bg-amber-600 text-white px-6 py-3 flex items-center gap-2 transition"
              >
                <Plus className="w-5 h-5" />
                <span className="font-bold tracking-wide">NEW DECK</span>
              </button>
            </div>

            {decks.length === 0 ? (
              <div className="bg-zinc-900 border-2 border-zinc-800 p-12 text-center">
                <FileText className="w-16 h-16 text-zinc-700 mx-auto mb-4" />
                <p className="text-zinc-500 text-lg">No decks yet. Create your first deck to get started!</p>
              </div>
            ) : (
              <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6">
                {decks.map(deck => (
                  <div key={deck.id} className="bg-zinc-900 border-2 border-zinc-800 hover:border-zinc-700 p-6 transition">
                    <div className="flex justify-between items-start mb-4">
                      <div>
                        <h3 className="text-xl font-bold text-white mb-2 tracking-wide">{deck.name}</h3>
                        <span className={`text-xs px-2 py-1 border ${
                          deck.type === 'hero' 
                            ? 'border-green-600 text-green-400' 
                            : 'border-amber-600 text-amber-400'
                        } tracking-wider`}>
                          {deck.type === 'hero' ? 'HERO DECK' : 'EQUIPMENT DECK'}
                        </span>
                      </div>
                      <button onClick={() => deleteDeck(deck.id)} className="text-red-500 hover:text-red-400 transition">
                        <Trash2 className="w-5 h-5" />
                      </button>
                    </div>

                    <div className="text-zinc-500 text-sm mb-4 flex items-center gap-2">
                      <FileText className="w-4 h-4" />
                      <span>{deck.cards.length} cards</span>
                    </div>

                    <div className="flex gap-2">
                      <button
                        onClick={() => viewDeck(deck)}
                        className="flex-1 bg-zinc-950 border border-zinc-700 hover:border-amber-600 text-white px-4 py-2 transition text-sm font-bold tracking-wide"
                      >
                        VIEW
                      </button>
                      <button
                        onClick={() => exportDeck(deck)}
                        className="flex-1 bg-zinc-950 border border-zinc-700 hover:border-green-600 text-white px-4 py-2 transition text-sm font-bold tracking-wide"
                      >
                        EXPORT
                      </button>
                    </div>
                  </div>
                ))}
              </div>
            )}
          </div>
        )}

        {currentTab === 'deck-view' && selectedDeck && (
          <div>
            <div className="flex justify-between items-center mb-8">
              <div>
                <button
                  onClick={() => setCurrentTab('view')}
                  className="text-amber-500 hover:text-amber-400 mb-2 flex items-center gap-2 font-bold tracking-wide"
                >
                  ‚Üê BACK TO DECKS
                </button>
                <h1 className="text-4xl font-bold text-white tracking-wide">{selectedDeck.name}</h1>
                <p className="text-zinc-500 mt-2">{selectedDeck.cards.length} cards</p>
              </div>
              <div className="flex gap-3">
                <button
                  onClick={() => setShowCustomize(true)}
                  className="bg-zinc-900 border-2 border-purple-600 hover:bg-purple-600 text-white px-4 py-2 flex items-center gap-2 transition"
                >
                  <Palette className="w-4 h-4" />
                  <span className="font-bold tracking-wide">CUSTOMIZE</span>
                </button>
                <button
                  onClick={() => exportDeck(selectedDeck)}
                  className="bg-zinc-900 border-2 border-green-600 hover:bg-green-600 text-white px-4 py-2 flex items-center gap-2 transition"
                >
                  <Printer className="w-4 h-4" />
                  <span className="font-bold tracking-wide">EXPORT</span>
                </button>
              </div>
            </div>

            <div style={{
              display: 'grid',
              gridTemplateColumns: 'repeat(auto-fill, 63mm)',
              gap: '5mm',
              justifyContent: 'center'
            }}>
              {selectedDeck.cards.map((card) => (
                <div key={card.id}>
                  <MTGCard card={card} customization={selectedDeck.customization} textSettings={textSettings} keywords={keywords} />
                </div>
              ))}
            </div>
          </div>
        )}

        {currentTab === 'export' && selectedDeck && (
          <div>
            <div className="flex justify-between items-center mb-8">
              <div>
                <button
                  onClick={() => setCurrentTab('deck-view')}
                  className="text-amber-500 hover:text-amber-400 mb-2 flex items-center gap-2 font-bold tracking-wide"
                >
                  ‚Üê BACK TO DECK
                </button>
                <h1 className="text-4xl font-bold text-white tracking-wide">EXPORT: {selectedDeck.name}</h1>
                <p className="text-zinc-500 mt-2">
                  {filteredExportCards.length === selectedDeck.cards.length 
                    ? `${selectedDeck.cards.length} cards ‚Ä¢ ${Math.ceil(selectedDeck.cards.length / 9)} page${Math.ceil(selectedDeck.cards.length / 9) !== 1 ? 's' : ''}`
                    : `Showing ${filteredExportCards.length} of ${selectedDeck.cards.length} cards ‚Ä¢ ${Math.ceil(filteredExportCards.length / 9)} page${Math.ceil(filteredExportCards.length / 9) !== 1 ? 's' : ''}`
                  }
                </p>
              </div>
              <div className="flex gap-3">
                <button
                  onClick={downloadAsHTML}
                  className="bg-zinc-900 border-2 border-green-600 hover:bg-green-600 text-white px-6 py-3 flex items-center gap-2 transition"
                >
                  <Download className="w-5 h-5" />
                  <span className="font-bold tracking-wide">DOWNLOAD PRINTABLE</span>
                </button>
                <button
                  onClick={() => window.print()}
                  className="bg-zinc-900 border-2 border-amber-600 hover:bg-amber-600 text-white px-6 py-3 flex items-center gap-2 transition"
                >
                  <Printer className="w-5 h-5" />
                  <span className="font-bold tracking-wide">PRINT NOW</span>
                </button>
              </div>
            </div>

            {/* FILTER BUTTONS */}
            <div className="mb-6">
              <div className="flex justify-between items-start mb-3">
                <h3 className="text-sm font-bold text-zinc-400 tracking-wide">FILTER BY STATE</h3>
                
                {/* Easy Print Toggle */}
                <button
                  onClick={() => setEasyPrintMode(!easyPrintMode)}
                  className={`px-4 py-2 font-bold tracking-wide transition flex items-center gap-2 ${
                    easyPrintMode
                      ? 'bg-purple-900/50 border-2 border-purple-600 text-purple-400'
                      : 'bg-zinc-900 border-2 border-zinc-800 text-zinc-400 hover:border-purple-700'
                  }`}
                >
                  <span className="text-lg">‚úÇÔ∏è</span>
                  <span>EASY PRINT {easyPrintMode ? 'ON' : 'OFF'}</span>
                </button>
              </div>
              
              <div className="flex gap-3">
                <button
                  onClick={() => setExportFilter('all')}
                  className={`px-6 py-3 font-bold tracking-wide transition ${
                    exportFilter === 'all'
                      ? 'bg-zinc-800 border-2 border-zinc-600 text-white'
                      : 'bg-zinc-900 border-2 border-zinc-800 text-zinc-400 hover:border-zinc-700'
                  }`}
                >
                  ALL CARDS
                </button>
                <button
                  onClick={() => setExportFilter('print-new')}
                  className={`px-6 py-3 font-bold tracking-wide transition ${
                    exportFilter === 'print-new'
                      ? 'bg-amber-900/50 border-2 border-amber-600 text-amber-400'
                      : 'bg-zinc-900 border-2 border-zinc-800 text-zinc-400 hover:border-amber-700'
                  }`}
                >
                  üñ®Ô∏è PRINT NEW
                </button>
                <button
                  onClick={() => setExportFilter('updated')}
                  className={`px-6 py-3 font-bold tracking-wide transition ${
                    exportFilter === 'updated'
                      ? 'bg-green-900/50 border-2 border-green-600 text-green-400'
                      : 'bg-zinc-900 border-2 border-zinc-800 text-zinc-400 hover:border-green-700'
                  }`}
                >
                  ‚úì UPDATED
                </button>
              </div>
            </div>

            <div className="bg-zinc-900 border-2 border-zinc-800 p-4 mb-6">
              <div className="mb-3">
                <p className="text-zinc-400 text-sm">
                  <strong className="text-green-500">‚úÖ RECOMMENDED:</strong> Click <strong>"DOWNLOAD PRINTABLE"</strong> to save an HTML file. 
                  Open it in your browser, then press Ctrl+P (Cmd+P on Mac) and select "Save as PDF". This works everywhere.
                </p>
              </div>
              <div>
                <p className="text-zinc-400 text-sm">
                  <strong className="text-amber-500">‚ö° ALTERNATIVE:</strong> Click <strong>"PRINT NOW"</strong> to try direct printing (may not work in all browsers).
                </p>
              </div>
            </div>

            {filteredExportCards.length === 0 ? (
              <div className="bg-zinc-900 border-2 border-green-600 p-12 text-center">
                <div className="text-6xl mb-4">‚úÖ</div>
                <h2 className="text-3xl font-bold text-green-500 mb-2 tracking-wider">ALL CAUGHT UP!</h2>
                <p className="text-zinc-400 text-lg">
                  {exportFilter === 'print-new' 
                    ? "No cards need printing. Everything's up to date!" 
                    : "No cards match this filter."}
                </p>
              </div>
            ) : (
              <>
                {easyPrintMode && (
                  <div className="bg-purple-900/30 border-2 border-purple-600 p-4 mb-6">
                    <p className="text-purple-400 text-sm">
                      <strong className="text-purple-300">‚úÇÔ∏è EASY PRINT MODE:</strong> Cards are tightly packed with no spacing. 
                      Cut straight down the columns and across the rows for fast batch cutting.
                    </p>
                  </div>
                )}
                
                <div data-export-content>
                  <A4PrintLayout 
                    deck={{...selectedDeck, cards: filteredExportCards}} 
                    textSettings={textSettings} 
                    keywords={keywords}
                    easyPrintMode={easyPrintMode}
                  />
                </div>
              </>
            )}
          </div>
        )}

        {currentTab === 'balancing' && (
          <div>
            <h1 className="text-4xl font-bold text-amber-500 mb-8 tracking-wider">BALANCING OVERVIEW</h1>
            
            <div className="grid grid-cols-2 gap-0 border-2 border-zinc-800">
              {/* DECK A */}
              <div className="border-r-2 border-zinc-800 p-6 bg-zinc-900">
                <div className="mb-6">
                  <h2 className="text-2xl font-bold text-green-500 mb-4 tracking-wide">DECK A</h2>
                  <select
                    value={balanceDeck1?.id || ''}
                    onChange={(e) => {
                      const deck = decks.find(d => d.id === parseInt(e.target.value));
                      setBalanceDeck1(deck || null);
                    }}
                    className="w-full bg-black text-white px-4 py-3 border-2 border-zinc-800 focus:border-green-600 focus:outline-none"
                  >
                    <option value="">Select a deck...</option>
                    {decks.filter(d => d.type === 'hero').map(deck => (
                      <option key={deck.id} value={deck.id}>{deck.name}</option>
                    ))}
                  </select>
                </div>

                {balanceDeck1 && <DecklistDisplay cards={balanceDeck1.cards} color="green" />}
                <DeckAnalysisPanel deck={balanceDeck1} analysis={deck1Analysis} color="green" />
              </div>

              {/* DECK B */}
              <div className="p-6 bg-zinc-900">
                <div className="mb-6">
                  <h2 className="text-2xl font-bold text-blue-500 mb-4 tracking-wide">DECK B</h2>
                  <select
                    value={balanceDeck2?.id || ''}
                    onChange={(e) => {
                      const deck = decks.find(d => d.id === parseInt(e.target.value));
                      setBalanceDeck2(deck || null);
                    }}
                    className="w-full bg-black text-white px-4 py-3 border-2 border-zinc-800 focus:border-blue-600 focus:outline-none"
                  >
                    <option value="">Select a deck...</option>
                    {decks.filter(d => d.type === 'hero' && d.id !== balanceDeck1?.id).map(deck => (
                      <option key={deck.id} value={deck.id}>{deck.name}</option>
                    ))}
                  </select>
                </div>

                {balanceDeck2 && <DecklistDisplay cards={balanceDeck2.cards} color="blue" />}
                <DeckAnalysisPanel deck={balanceDeck2} analysis={deck2Analysis} color="blue" />
              </div>
            </div>
          </div>
        )}

        {currentTab === 'text-tweaks' && (
          <div>
            <h1 className="text-4xl font-bold text-amber-500 mb-8 tracking-wider">TEXT TWEAKS</h1>
            
            <div className="grid lg:grid-cols-2 gap-8">
              <div className="bg-zinc-900 border-2 border-zinc-800 p-6">
                <h2 className="text-2xl font-bold text-white mb-4 tracking-wide">KEYWORDS</h2>
                <p className="text-zinc-400 text-sm mb-6">Words that will appear in bold on all cards</p>
                
                <div className="flex gap-2 mb-4">
                  <input
                    type="text"
                    value={newKeyword}
                    onChange={(e) => setNewKeyword(e.target.value)}
                    onKeyPress={(e) => e.key === 'Enter' && addKeyword()}
                    placeholder="Add keyword (e.g., Rage)"
                    className="flex-1 bg-black text-white px-4 py-2 border-2 border-zinc-800 focus:border-amber-600 focus:outline-none"
                  />
                  <button
                    onClick={addKeyword}
                    className="bg-zinc-950 border-2 border-amber-600 hover:bg-amber-600 text-white px-6 py-2 transition font-bold"
                  >
                    ADD
                  </button>
                </div>

                <div className="space-y-2">
                  {keywords.length === 0 ? (
                    <div className="text-zinc-600 text-center py-8 border-2 border-dashed border-zinc-800">
                      No keywords yet. Add your first keyword above.
                    </div>
                  ) : (
                    keywords.map(keyword => (
                      <div key={keyword} className="flex items-center justify-between bg-zinc-950 border border-zinc-800 px-4 py-2">
                        <span className="text-white font-mono">{keyword}</span>
                        <button onClick={() => removeKeyword(keyword)} className="text-red-500 hover:text-red-400 transition">
                          <Trash2 className="w-4 h-4" />
                        </button>
                      </div>
                    ))
                  )}
                </div>
              </div>

              <div className="bg-zinc-900 border-2 border-zinc-800 p-6">
                <h2 className="text-2xl font-bold text-white mb-4 tracking-wide">FONT SIZES</h2>
                <p className="text-zinc-400 text-sm mb-6">Adjust text sizes (in pt)</p>
                
                <div className="space-y-4">
                  <div>
                    <label className="block text-zinc-400 mb-2 font-bold text-sm">Effect Text - Standard Size</label>
                    <input
                      type="number"
                      value={textSettings.standardEffectSize}
                      onChange={(e) => updateTextSetting('standardEffectSize', e.target.value)}
                      min="6"
                      max="24"
                      className="w-full bg-black text-white px-4 py-2 border-2 border-zinc-800 focus:border-amber-600 focus:outline-none"
                    />
                    <p className="text-zinc-600 text-xs mt-1">Auto-sizes down from this size to fit</p>
                  </div>

                  <div>
                    <label className="block text-zinc-400 mb-2 font-bold text-sm">Effect Text - Minimum Size</label>
                    <input
                      type="number"
                      value={textSettings.minEffectSize}
                      onChange={(e) => updateTextSetting('minEffectSize', e.target.value)}
                      min="4"
                      max="16"
                      className="w-full bg-black text-white px-4 py-2 border-2 border-zinc-800 focus:border-amber-600 focus:outline-none"
                    />
                    <p className="text-zinc-600 text-xs mt-1">Won't shrink smaller than this</p>
                  </div>

                  <div className="border-t border-zinc-800 pt-4 mt-4">
                    <h3 className="text-white font-bold mb-3 text-sm">Other Text Elements</h3>
                    
                    {[
                      ['cardNameSize', 'Card Name Size'],
                      ['typeLineSize', 'Type Line Size'],
                      ['costSize', 'Mana Cost Size']
                    ].map(([key, label]) => (
                      <div key={key} className="mb-3">
                        <label className="block text-zinc-400 mb-1 text-xs">{label}</label>
                        <input
                          type="number"
                          value={textSettings[key]}
                          onChange={(e) => updateTextSetting(key, e.target.value)}
                          min="4"
                          max="20"
                          className="w-full bg-black text-white px-3 py-1 text-sm border-2 border-zinc-800 focus:border-amber-600 focus:outline-none"
                        />
                      </div>
                    ))}
                  </div>
                </div>

                <div className="mt-6 p-4 bg-zinc-950 border border-zinc-800">
                  <p className="text-amber-500 text-xs font-bold mb-1">üí° TIP</p>
                  <p className="text-zinc-400 text-xs">
                    Effect text auto-sizes from Standard ‚Üí Minimum to fit the card. Other elements use fixed sizes.
                  </p>
                </div>
              </div>
            </div>
          </div>
        )}
      </div>

      {/* MODALS */}
      {showCreateModal && (
        <div className="fixed inset-0 bg-black/90 flex items-center justify-center z-50 p-4">
          <div className="bg-zinc-900 border-2 border-zinc-800 p-8 max-w-2xl w-full">
            <h2 className="text-3xl font-bold text-amber-500 mb-6 tracking-wider">CREATE NEW DECK</h2>

            <div className="space-y-6">
              <div>
                <label className="block text-zinc-400 mb-2 font-bold tracking-wide">DECK NAME</label>
                <input
                  type="text"
                  value={newDeckName}
                  onChange={(e) => setNewDeckName(e.target.value)}
                  placeholder="e.g., Barbarian Starter"
                  className="w-full bg-black text-white px-4 py-3 border-2 border-zinc-800 focus:border-amber-600 focus:outline-none"
                />
              </div>

              <div>
                <label className="block text-zinc-400 mb-2 font-bold tracking-wide">DECK TYPE</label>
                <div className="grid grid-cols-2 gap-4">
                  {[
                    ['hero', '‚öîÔ∏è', 'HERO DECK', '40-card class deck'],
                    ['equipment', 'üõ°Ô∏è', 'EQUIPMENT DECK', '45-item shop deck']
                  ].map(([type, emoji, title, desc]) => (
                    <button
                      key={type}
                      onClick={() => setNewDeckType(type)}
                      className={`p-4 border-2 transition ${
                        newDeckType === type
                          ? 'border-amber-600 bg-zinc-950 text-white'
                          : 'border-zinc-800 bg-black text-zinc-500 hover:border-zinc-700'
                      }`}
                    >
                      <div className="text-4xl mb-2">{emoji}</div>
                      <div className="font-bold tracking-wide">{title}</div>
                      <div className="text-sm opacity-75">{desc}</div>
                    </button>
                  ))}
                </div>
              </div>

              <div>
                <label className="block text-zinc-400 mb-2 font-bold tracking-wide">UPLOAD CSV</label>
                <label className="flex flex-col items-center justify-center h-32 border-2 border-dashed border-zinc-800 cursor-pointer hover:border-zinc-700 transition">
                  <Upload className="w-10 h-10 text-zinc-600 mb-2" />
                  <span className="text-zinc-500">
                    {uploadedCards.length > 0 ? `${uploadedCards.length} CARDS LOADED` : 'CLICK TO UPLOAD CSV'}
                  </span>
                  <input type="file" accept=".csv" onChange={handleFileUpload} className="hidden" />
                </label>
              </div>
            </div>

            <div className="flex gap-4 mt-8">
              <button
                onClick={() => {
                  setShowCreateModal(false);
                  setNewDeckName('');
                  setUploadedCards([]);
                }}
                className="flex-1 bg-zinc-950 border-2 border-zinc-800 hover:border-red-600 text-white px-6 py-3 transition font-bold tracking-wide"
              >
                DISCARD
              </button>
              <button
                onClick={saveDeck}
                className="flex-1 bg-zinc-950 border-2 border-amber-600 hover:bg-amber-600 text-white px-6 py-3 transition font-bold tracking-wide"
              >
                SAVE DECK
              </button>
            </div>
          </div>
        </div>
      )}

      {showCustomize && selectedDeck && (
        <div className="fixed inset-0 bg-black/90 flex items-center justify-center z-50 p-4 overflow-y-auto">
          <div className="bg-zinc-900 border-2 border-zinc-800 p-8 max-w-3xl w-full my-8">
            <h2 className="text-3xl font-bold text-amber-500 mb-6 tracking-wider">CUSTOMIZE: {selectedDeck.name}</h2>

            <div className="space-y-6">
              <div>
                <label className="block text-zinc-400 mb-3 font-bold tracking-wide">FONT FAMILY</label>
                <select
                  value={selectedDeck.customization.font}
                  onChange={(e) => updateDeckCustomization({ font: e.target.value })}
                  className="w-full bg-black text-white px-4 py-3 border-2 border-zinc-800 focus:border-amber-600 focus:outline-none"
                >
                  {[
                    ['Arial, sans-serif', 'Arial'],
                    ['Helvetica, sans-serif', 'Helvetica'],
                    ['"Times New Roman", serif', 'Times New Roman'],
                    ['Georgia, serif', 'Georgia'],
                    ['"Courier New", monospace', 'Courier New'],
                    ['Verdana, sans-serif', 'Verdana']
                  ].map(([value, label]) => (
                    <option key={value} value={value}>{label}</option>
                  ))}
                </select>
              </div>

              <div>
                <label className="block text-zinc-400 mb-3 font-bold tracking-wide">BORDER COLORS</label>
                <div className="grid md:grid-cols-2 gap-4">
                  {Object.keys(selectedDeck.customization).filter(k => k !== 'font').map(category => (
                    <div key={category} className="bg-zinc-950 border-2 border-zinc-800 p-4">
                      <h3 className="text-white font-bold mb-3 capitalize tracking-wide">{category}</h3>
                      <div className="flex items-center gap-3">
                        <input
                          type="color"
                          value={selectedDeck.customization[category].color}
                          onChange={(e) => updateDeckCustomization({ [category]: { color: e.target.value } })}
                          className="w-12 h-8 cursor-pointer"
                        />
                        <input
                          type="text"
                          value={selectedDeck.customization[category].color}
                          onChange={(e) => updateDeckCustomization({ [category]: { color: e.target.value } })}
                          className="flex-1 bg-black text-white px-3 py-2 text-sm border-2 border-zinc-800 focus:border-amber-600 focus:outline-none"
                        />
                      </div>
                    </div>
                  ))}
                </div>
              </div>
            </div>

            <button
              onClick={() => setShowCustomize(false)}
              className="w-full mt-8 bg-zinc-950 border-2 border-amber-600 hover:bg-amber-600 text-white px-6 py-3 transition font-bold tracking-wide"
            >
              DONE
            </button>
          </div>
        </div>
      )}

      {showDeleteConfirm && (
        <div className="fixed inset-0 bg-black/90 flex items-center justify-center z-50 p-4">
          <div className="bg-zinc-900 border-2 border-zinc-800 p-8 max-w-md w-full">
            <h2 className="text-3xl font-bold text-red-500 mb-6 tracking-wider">DELETE DECK?</h2>
            <p className="text-zinc-400 mb-8 text-lg">
              Are you sure you want to delete this deck? This action cannot be undone.
            </p>

            <div className="flex gap-4">
              <button
                onClick={() => {
                  setShowDeleteConfirm(false);
                  setDeckToDelete(null);
                }}
                className="flex-1 bg-zinc-950 border-2 border-zinc-800 hover:border-zinc-700 text-white px-6 py-3 transition font-bold tracking-wide"
              >
                CANCEL
              </button>
              <button
                onClick={confirmDelete}
                className="flex-1 bg-zinc-950 border-2 border-red-600 hover:bg-red-600 text-white px-6 py-3 transition font-bold tracking-wide"
              >
                DELETE
              </button>
            </div>
          </div>
        </div>
      )}

      <style>{`
        @media print {
          body { margin: 0; padding: 0; background: white !important; }
          @page { size: A4; margin: 0; }
          .min-h-screen { display: none; }
          div[style*="210mm"] { display: block !important; }
        }
      `}</style>
    </div>
  );
};

export default CardGenerator;